# Experimental Game 01 
![platform](https://img.shields.io/badge/Platform-Win--64-blue)
![engine](https://img.shields.io/badge/Engine-Unity%202020.2.1f1-orange)
![language](https://img.shields.io/badge/Language-C%23-blueviolet)
![Discord Server](https://img.shields.io/discord/133525034298900480?label=Personal%20Server&logo=Discord)
![Last Commit](https://img.shields.io/github/last-commit/CadeXLegend/Experimental_Game_01?label=Last%20Commit)

![Image of Game as of 15-Jan-2021](https://i.imgur.com/h9glcD9.jpg)
![](https://i.imgur.com/YquKU7I.gif)
<iframe width="1903" height="800" src="https://www.youtube.com/embed/AOyROyHkBFU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Creating a game to experiment with code techniques, improve on knowledge, workflow, and to have fun while doing so!

## Inspiration
The inspiration for this game comes from a life time really.  I've been playing games since I was 3 years old.  I started with games like Warcraft 1/2, floppy disk games, MAME32 games, games like Pyjama Sam, Escape From Monkey Island, and so on.  I absolutely adored these games and it birthed in me a flame, a passion, and a desire for games.  I eventually fell in love with titles such as SW:KOTOR, Warcraft 3, FF12, and even though I have maintained an extremely diverse interest in all genres, I have always been inexplicably drawn to methodical, thought-oriented turn-based strategy games.  I still recall more recent fond memories of games such as Total War: SHOGUN 2, Civ 5, Endless Legend, and older ones of the RTS days like The Lord of the Rings: The Battle for Middle-earth II, Command & Conquer Generals/Tiberium Wars, and so on.  The most recent turn-based games I thoroughly enjoyed were Battle Chasers: Nightwar, Cardinal Quest 1 & 2, and Divinity: Original Sin 2.

This game is heavily inspired by the games below, as well as inspired in other ways by the games above and more unmentioned due to not wanting to write multiple paragraphs.

I recently found [Into The Breach](https://store.steampowered.com/app/590380/Into_the_Breach/) which seems like a fantastic game and somewhat similar in concept so I will try it out!

### Cardinal Quest 1
http://cardinalquest.com/

### Cardinal Quest 2
http://cardinalquest2.com/, 
https://store.steampowered.com/app/378030/Cardinal_Quest_2/, 
https://play.google.com/store/apps/details?id=com.kongregate.mobile.cardinalquest.google&hl=en

### Divinity: Original Sin 2
https://store.steampowered.com/app/435150/Divinity_Original_Sin_2__Definitive_Edition/

## Prerequisites

To use this project on your local machine, make sure you have Unity 2020.2.1f1 installed.

```
You can get Unity from here: https://unity3d.com/get-unity/download

I recommend using Unity Hub to manage the versions and projects.

This project has got Unit Testing enabled.  Feel free to disable it.

If there are any specific dependencies or particular assembly configurations required which are present in this project, they should all be included in this repo and work "out of the box".  If this is not the case, please notify me here on Github or by email. 
```

## Built With

* [Unity](https://unity3d.com) - The engine used to make the game.
* [Visual Studio](https://visualstudio.microsoft.com) - The IDE used to manage the coding side of things.

## License

[Creative Commons CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)

## Acknowledgments

* StackOverflow
* Unity & it's Scripting API
* The Visual Studio Team
* All the incredibly creative developers out there
* YouTubers, Forum posters, and the incredible community present in the sphere of Programming & Game Development
* My friends
* My mum

## Some Noteworthy Things To Remember

### KISS: 
Keep It Stupidly Simple!

### [SOLID](https://en.wikipedia.org/wiki/SOLID):
* [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)
    
    A class should only have a single responsibility, that is, only changes to one part of the software's specification should be able
    to affect the specification of the class.
* [Open Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)
    
    Software entities should be open for extension, but closed for modification.
* [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
    
    Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.
* [Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
    
    Many client-specific interfaces are better than one general-purpose interface.
* [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
    
    One should depend upon abstractions, not concretions.

### [The Zen of Python](https://www.python.org/dev/peps/pep-0020/):
Beautiful is better than ugly.

Explicit is better than implicit.

Simple is better than complex.

Complex is better than complicated.

Flat is better than nested.

Sparse is better than dense.

Readability counts.

Special cases aren't special enough to break the rules.

Although practicality beats purity.

Errors should never pass silently.

Unless explicitly silenced.

In the face of ambiguity, refuse the temptation to guess.

There should be one-- and preferably only one --obvious way to do it.

Although that way may not be obvious at first unless you're Dutch.

Now is better than never.

Although never is often better than *right* now.

If the implementation is hard to explain, it's a bad idea.

If the implementation is easy to explain, it may be a good idea.

Namespaces are one honking great idea -- let's do more of those!


